[{"title":"悲观锁","url":"/everyone/2025/10/30/hello-world/","content":"一、悲观锁的由来：从 “超卖事故” 说起咱们先从两个场景切入，看懂为啥需要悲观锁：\n1. 生活场景：卫生间的 “并发冲突”你去公司卫生间，推门发现没人但没锁门 —— 这时候如果突然冲进来另一个人，就会发生 “资源冲突”。所以聪明的做法是 先反锁再使用：默认 “一定会有人抢”，提前锁死资源，自己用完再释放。\n2. 编程场景：不加锁的 “库存灾难”假设电商秒杀某商品，库存 100 件，1000 个用户同时下单。如果不加锁，代码可能写成这样：\n// 无锁的库存扣减（有严重问题！）class BadStock &#123;   private int stock = 100;   // 扣减库存：先判断再修改   public void deduct(int num) &#123;       if (stock &gt;= num) &#123; // 步骤1：判断库存           // 模拟网络延迟（比如查数据库、调用支付接口）           try &#123; Thread.sleep(10); &#125; catch (Exception e) &#123;&#125;           stock -= num; // 步骤2：扣减库存           System.out.println(&quot;扣减成功，剩余：&quot; + stock);       &#125;   &#125;&#125;\n\n运行结果灾难：1000 个线程同时执行时，会出现 “库存变成负数” 的超卖 —— 因为多个线程同时通过步骤 1 的判断，都认为库存充足，最后同时执行步骤 2 的扣减。\n这就是 并发冲突：多个线程同时操作共享资源（库存），导致数据混乱。悲观锁的诞生就是为了解决这个问题：操作前先上锁，同一时间只允许一个线程动手，像卫生间反锁一样阻断冲突。\n二、悲观锁的核心概念：3 个特点讲透\n悲观锁是一种 “先防御后操作” 的并发策略，它默认 “线程一定会抢资源”，所以在访问共享数据前主动获取锁，确保只有持锁线程能操作，其他线程必须排队等待。\n\n关键特点用 “卫生间模型” 类比：\n\n\n\n特点\n技术解释\n生活对应场景\n\n\n\n独占性\n锁被一个线程持有后，其他线程无权使用\n卫生间反锁后，只有里面的人能使用\n\n\n阻塞性\n没拿到锁的线程暂停执行，不会占用 CPU\n没抢到卫生间的人在门口排队等待\n\n\n强一致性\n能 100% 避免冲突，但会牺牲性能\n虽然排队费时间，但绝对不会撞车\n\n\n三、Java 中悲观锁的实现方式：2 种锁工具深度解析Java 里悲观锁分 “隐式锁”（synchronized）和 “显式锁”（ReentrantLock），两者原理和用法差异很大，重点用图示拆解难点。\n1. 隐式锁：synchronized（懒人专属，JVM 帮你管锁）synchronized 是 Java 自带的 “傻瓜式锁”，不用手动开关锁，JVM 自动处理一切。但底层的 Monitor（监视器锁）机制 是难点，必须看图理解。\n（1）Monitor 机制可视化解析（核心难点！）Monitor 本质是个 “管程模型”，像个带门卫的房间，共享资源（比如库存变量）放在房间里，只有拿到钥匙的线程能进。\n┌─────────────────────────────────┐│           Monitor（房间）        ││  ┌─────────┐                    ││  │  owner  │ → 线程A（持锁中）   │  线程C → 被阻塞，进入entrySet排队│  └─────────┘                    ││  ┌─────────┐                    │  线程D → 调用wait()，进入waitSet等待│  │ waitSet │ → 线程B（等待唤醒） ││  └─────────┘                    ││  ┌─────────┐                    ││  │ entrySet│ → 线程C（排队抢锁） ││  └─────────┘                    │└─────────────────────────────────┘\n\n关键逻辑（对应 synchronized 执行流程）：\n\n线程进入 synchronized 代码块时，会向 Monitor 申请 “钥匙”（加锁）；\n\n如果 Monitor 没人持有（owner 为空），线程直接成为 owner，独占资源；\n\n如果已有线程持有钥匙（比如线程 A），新线程（线程 C）会进入 entrySet 队列 阻塞等待；\n\n线程执行完代码块，或发生异常，JVM 会自动释放钥匙（owner 置空），并唤醒 entrySet 里的一个线程抢锁；\n\n如果线程在锁内调用 wait() 方法（比如等待其他线程通知），会暂时释放钥匙，进入 waitSet 队列，被 notify() 唤醒后再回 entrySet 排队。\n\n\n（2）synchronized 的 3 种用法（代码实战）class SyncDemo &#123;   // 1. 锁实例方法（锁对象是 this，即当前 SyncDemo 实例）   public synchronized void lockMethod() &#123;       // 业务逻辑   &#125;   // 2. 锁静态方法（锁对象是 SyncDemo.class，全类唯一）   public static synchronized void lockStaticMethod() &#123;       // 业务逻辑   &#125;   // 3. 锁代码块（锁对象可自定义，灵活控制粒度）   public void lockBlock() &#123;       Object lockObj = new Object();       synchronized (lockObj) &#123; // 只锁这部分代码           // 核心业务（比如库存扣减）       &#125;   &#125;&#125;\n\n2. 显式锁：ReentrantLock（灵活王者，手动控锁）Java 1.5 新增的 java.util.concurrent.locks.Lock 接口实现类，需要手动 lock() 加锁、unlock() 释放锁，功能比 synchronized 强 10 倍。核心难点是 AQS 框架原理。\n（1）AQS 框架可视化解析（必懂！）ReentrantLock 基于 AQS（AbstractQueuedSynchronizer） 实现，本质是个 “带优先级的排队系统”，用双向链表存储等待线程，通过 CAS 操作（Compare And Swap）控制锁的获取释放。\n┌─────────────────────────────────────────────┐│            ReentrantLock （锁对象）          ││  ┌─────────────┐  持有线程：线程A             ││  │   state=1   │  （state&gt;0表示锁被占用）     ││  └─────────────┘                             │└───────────────────────┬─────────────────────┘                       │                       ▼┌─────────────────────────────────────────────┐│          AQS 等待队列（双向链表）            ││  ┌───────────┐  ┌───────────┐  ┌───────────┐ ││  │  线程B    │→│  线程C    │→│  线程D    │ ││  │  等待中   │←│  等待中   │←│  等待中   │ ││  └───────────┘  └───────────┘  └───────────┘ │└─────────────────────────────────────────────┘\n\n关键逻辑：\n\n线程调用 lock() 时，AQS 先检查 state 变量（0 &#x3D; 无锁，&gt;0 &#x3D; 有锁）；\n\n如果 state=0，用 CAS 操作把 state 改成 1，线程成为持锁线程；\n\n如果 state≠0（锁被占用），线程封装成 Node 节点 加入等待队列，进入阻塞状态；\n\n持锁线程调用 unlock() 时，把 state 改回 0，唤醒队列头节点的线程重新抢锁。\n\n\n（2）ReentrantLock 的核心优势（代码实战）比 synchronized 多 3 个关键功能，全是解决实际问题的：\nimport java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;import java.util.concurrent.TimeUnit;class LockDemo &#123;   private final Lock lock = new ReentrantLock(true); // true=公平锁，默认非公平   // 优势1：支持超时加锁，避免死锁   public void tryLockWithTimeout() &#123;       try &#123;           // 尝试加锁，3秒没拿到就放弃           if (lock.tryLock(3, TimeUnit.SECONDS)) &#123;               try &#123;                   // 业务逻辑               &#125; finally &#123;                   lock.unlock(); // 必须在finally释放！               &#125;           &#125; else &#123;               System.out.println(&quot;抢锁超时，放弃操作&quot;);           &#125;       &#125; catch (InterruptedException e) &#123;           Thread.currentThread().interrupt();       &#125;   &#125;   // 优势2：支持中断等待   public void lockWithInterrupt() throws InterruptedException &#123;       lock.lockInterruptibly(); // 等待时可被中断       try &#123;           // 业务逻辑       &#125; finally &#123;           lock.unlock();       &#125;   &#125;   // 优势3：可重入性（同一线程多次加锁）   public void reentrantDemo() &#123;       lock.lock();       try &#123;           System.out.println(&quot;第一次加锁&quot;);           lock.lock(); // 同一线程再次加锁，不会死锁           try &#123;               System.out.println(&quot;第二次加锁&quot;);           &#125; finally &#123;               lock.unlock(); // 释放第二次锁           &#125;       &#125; finally &#123;           lock.unlock(); // 释放第一次锁（次数必须匹配！）       &#125;   &#125;&#125;\n\n（3）两种锁的核心区别（可视化对比表）\n\n\n维度\nsynchronized\nReentrantLock\n\n\n\n锁管理\n隐式（JVM 自动加解锁）\n显式（手动 lock&#x2F;unlock）\n\n\n功能\n仅基础同步\n支持超时、中断、公平锁\n\n\n可重入性\n支持（自动计数）\n支持（手动计数，需匹配释放次数）\n\n\n性能\nJDK1.6 后优化，与 Lock 接近\n高并发下略优，功能更灵活\n\n\n适用场景\n简单同步（单方法 &#x2F; 代码块）\n复杂场景（秒杀、分布式事务）\n\n\n// 图示：synchronized vs ReentrantLock 功能对比┌─────────────────────────────────────┐│            功能覆盖范围             ││  ┌─────────────┐  ┌─────────────┐   ││  │ ReentrantLock│  │ synchronized│   ││  │ （大圆圈）   │  │ （小圆圈）   │   ││  └─────────────┘  └─────────────┘   ││  超时锁  中断锁  公平锁  基础同步   │└─────────────────────────────────────┘\n\n四、悲观锁的应用场景：3 类场景必须用不是所有并发都需要悲观锁，这 3 种情况优先选：\n1. 高冲突场景：秒杀、抢购特点：1000 个线程抢 100 个资源，冲突概率极高。\n案例：电商秒杀库存扣减，用 ReentrantLock 加锁，配合超时机制避免线程拥堵。\n代码片段：\n2. 强一致性场景：金融交易特点：数据错 1 分钱都不行，必须 100% 准确。\n案例：银行转账（A 转 B 100 元），需保证 “A 扣钱” 和 “B 加钱” 原子执行，用 synchronized 或数据库悲观锁。\n数据库悲观锁示例（配合 Java 事务）：\n3. 长操作场景：批量数据处理特点：操作耗时久（比如批量导入 1000 条数据），期间容易被其他线程打断。\n案例：Excel 批量导入用户数据，需保证导入过程中数据不被篡改，用 ReentrantLock 加锁，避免中途冲突。\n五、使用悲观锁的注意事项：4 个坑别踩1. 坑 1：锁范围过大（“锁膨胀”）错误示范：把整个方法加锁，包括无关的查询操作：\n正确做法：只锁核心代码块（锁粒度最小化）：\n2. 坑 2：死锁（最致命！）死锁的 4 个必要条件（缺一不可，破坏任何一个即可避免）：\n死锁形成图示：\n线程A → 持有LOCK\\_A → 等待LOCK\\_B ▲                    │ │                    ▼线程B → 持有LOCK\\_B → 等待LOCK\\_A\n\n避免方法：\n\n统一锁顺序：所有线程都先拿 LOCK_A，再拿 LOCK_B（破坏 “循环等待”）；\n\n超时释放：用 ReentrantLock 的 tryLock(timeout)（破坏 “持有并等待”）；\n\n主动中断：用 lockInterruptibly() 响应中断（破坏 “不可剥夺”）。\n\n\n死锁检测工具：JDK 自带的 jconsole，步骤如下：\n\n启动程序，打开 JDK 的 bin 目录，双击 jconsole.exe；\n\n选择要监控的 Java 进程，点击 “连接”；\n\n切换到 “线程” 标签，点击 “检测死锁”，即可看到死锁线程信息。\n\n\n3. 坑 3：忽略可重入性的计数问题ReentrantLock 手动加锁 n 次，必须释放 n 次，否则锁不会释放：\n// 错误：加锁2次，释放1次，导致锁泄漏public void wrongReentrant() &#123;   lock.lock();   lock.lock(); // 第二次加锁   try &#123;       // 业务逻辑   &#125; finally &#123;       lock.unlock(); // 只释放1次，锁还被持有！   &#125;&#125;\n\n4. 坑 4：高并发下的性能瓶颈悲观锁会导致线程阻塞、上下文切换（线程从运行到阻塞再唤醒的开销）。如果并发量极高但冲突少（比如查询多、修改少的用户列表），用悲观锁会浪费 CPU，此时应换 乐观锁（用 version 字段判断数据是否被修改）。\n六、典型案例：从 “超卖” 到 “死锁修复” 全实战案例 1：synchronized 解决库存超卖（新手入门）需求：100 个线程同时扣减库存，避免超卖。\n完整代码 + 运行分析：\nclass SafeStockWithSync &#123;   private int stock = 100;   // 同步方法：锁对象是 this   public synchronized void deduct(int num) &#123;       if (stock &gt;= num) &#123;           System.out.println(Thread.currentThread().getName() +                              &quot;：当前库存&quot; + stock);           stock -= num;           System.out.println(Thread.currentThread().getName() +                              &quot;：扣减后&quot; + stock);       &#125; else &#123;           System.out.println(Thread.currentThread().getName() +                              &quot;：库存不足&quot;);       &#125;   &#125;&#125;public class SyncStockTest &#123;   public static void main(String\\[] args) &#123;       SafeStockWithSync stock = new SafeStockWithSync();       // 启动100个线程，每个扣1件       for (int i = 0; i &lt; 100; i++) &#123;           new Thread(() -&gt; stock.deduct(1), &quot;线程&quot; + i).start();       &#125;   &#125;&#125;\n\n运行结果：线程依次执行，库存从 100 减到 0，无超卖。因为 synchronized 保证了 deduct 方法同一时间只有一个线程能执行。\n案例 2：ReentrantLock 实现秒杀超时控制（进阶）需求：秒杀时，线程抢锁超过 2 秒就放弃，避免大量线程阻塞。\n核心代码：\n运行结果：部分线程抢锁成功，部分超时放弃，避免了所有线程阻塞等待。\n案例 3：死锁修复（反面→正面）反面案例：两个线程互相抢锁，导致死锁（原代码见前文）。\n修复方案：统一锁的获取顺序，都先拿 LOCK_A，再拿 LOCK_B。\n修复后代码：\n运行结果：线程 1 先拿到 A，执行完释放后，线程 2 拿到 A，不会死锁（破坏了 “循环等待” 条件）。\n七、总结：悲观锁的 “用武之地” 与 “避坑指南”1. 什么时候用？\n✅ 冲突多（秒杀、抢购）；\n\n✅ 一致性要求高（金融、支付）；\n\n✅ 操作时间长（批量处理、长事务）。\n\n\n2. 选 synchronized 还是 ReentrantLock？\n简单场景（单方法同步）→ 用 synchronized（省心，不易错）；\n\n复杂场景（超时、中断、公平锁）→ 用 ReentrantLock（灵活，功能强）。\n\n\n3. 核心避坑口诀：“锁粒度要小，顺序要统一，超时加中断，释放要牢记”。\n\n（注：文档部分内容可能由 AI 生成）\n\n","categories":["每日一论"],"tags":["悲观锁"]},{"title":"从CHL到AQS","url":"/everyone/2025/11/01/%E4%BB%8ECHL%E5%88%B0AQS-1761997399971/","content":"从CHL到AQS：Java并发同步框架的底层演进在Java并发编程中，AbstractQueuedSynchronizer（AQS）无疑是核心中的核心。无论是ReentrantLock、Semaphore，还是CountDownLatch，其底层都依赖AQS实现同步控制。但鲜有人知的是，AQS的设计并非凭空出现——它的同步队列思想源自一种经典的自旋锁实现：CLH锁（Craig, Landin, and Hagersten Lock）。\n本文将从CLH锁的原理出发，逐步解析AQS如何借鉴并优化CLH的设计，最终成为Java并发同步的基石。我们会深入源码细节，理清从CLH到AQS的技术演进脉络。\n一、CLH锁：自旋锁的经典实现CLH锁是1993年由Craig、Landin和Hagersten提出的一种基于链表的自旋锁，其核心特点是公平性（线程按申请顺序获取锁）和低开销（通过自旋前驱节点状态实现锁竞争）。\n1.1 CLH锁的核心设计思想CLH锁的核心是一个隐式的单向链表：每个线程在竞争锁时，会创建一个代表自身的节点，并将其加入链表尾部；线程通过自旋前驱节点的状态判断是否能获取锁——如果前驱节点释放了锁（状态为“释放”），当前线程即可获取锁。\n这种设计的巧妙之处在于：\n\n锁竞争通过“观察前驱”实现，避免了对全局变量的直接竞争；\n链表结构天然保证了公平性（先入队的线程先获取锁）；\n自旋操作仅针对前驱节点，局部性更好，缓存效率高。\n\n1.2 CLH锁的Java实现（简化版）为了理解CLH的工作机制，我们先实现一个简化版的CLH锁：\npublic class CLHLock &#123;    // 节点内部类：保存当前线程的锁状态    private static class Node &#123;        // 锁状态：true表示持有锁，false表示释放锁        volatile boolean locked;    &#125;    // 尾节点（原子引用，保证并发安全）    private final AtomicReference&lt;Node&gt; tail = new AtomicReference&lt;&gt;(new Node());    // 线程本地变量：保存当前线程的节点    private final ThreadLocal&lt;Node&gt; currentNode = ThreadLocal.withInitial(Node::new);    // 线程本地变量：保存当前线程的前驱节点    private final ThreadLocal&lt;Node&gt; prevNode = new ThreadLocal&lt;&gt;();    // 获取锁    public void lock() &#123;        // 1. 创建当前线程的节点（默认持有锁状态）        Node node = currentNode.get();        node.locked = true;        // 2. 将当前节点加入链表尾部（原子操作），并获取前驱节点        Node prev = tail.getAndSet(node);        prevNode.set(prev);        // 3. 自旋等待：直到前驱节点释放锁（prev.locked变为false）        while (prev.locked) &#123;            // 自旋（可加入Thread.yield()减少CPU消耗）        &#125;    &#125;    // 释放锁    public void unlock() &#123;        // 1. 获取当前线程的节点        Node node = currentNode.get();        // 2. 释放锁（将状态设为false，通知后继节点）        node.locked = false;        // 3. 帮助GC：将当前节点指向自身前驱（当前线程后续无需访问该节点）        currentNode.set(prevNode.get());    &#125;&#125;\n\n\n1.3 CLH锁的执行流程解析\n初始化：tail指向一个空节点（哨兵节点），每个线程通过ThreadLocal维护自己的currentNode（当前节点）和prevNode（前驱节点）。\n\n获取锁（lock）：\n\n线程创建自身节点并标记为locked=true（表示“需要持有锁”）；\n通过tail.getAndSet(node)将节点加入链表尾部，同时拿到前驱节点prev；\n自旋检测prev.locked：如果前驱持有锁（prev.locked=true），则继续等待；直到前驱释放锁（prev.locked=false），当前线程获取锁成功。\n\n\n释放锁（unlock）：\n\n线程将自身节点的locked设为false（通知后继节点“可以获取锁了”）；\n将currentNode指向prevNode（帮助GC回收旧节点，避免内存泄漏）。\n\n\n\n1.4 CLH锁的优缺点优点：\n\n公平性：严格按照线程入队顺序获取锁；\n高效性：自旋仅关注前驱节点，缓存局部性好；\n可扩展性：链表结构支持大量线程竞争，不会像全局锁那样产生热点竞争。\n\n缺点：\n\n自旋消耗CPU：若锁持有时间较长，自旋会浪费大量CPU资源；\n不适合长耗时操作：仅适合锁持有时间极短的场景；\n无法直接支持“条件等待”（如wait/notify）。\n\n二、AQS：从CLH到同步队列的演进AQS（AbstractQueuedSynchronizer）是JDK 1.5引入的同步框架，它借鉴了CLH锁的“队列等待”思想，但针对Java的线程模型做了大幅优化，解决了CLH的核心痛点（如自旋消耗、长耗时场景支持）。\n2.1 AQS的核心目标AQS的设计目标是为同步工具（锁、信号量等）提供统一的基础框架，核心解决三个问题：\n\n线程竞争的排队机制（同步队列）；\n共享资源的状态管理（state变量）；\n线程的阻塞与唤醒（结合LockSupport）。\n\n其中，同步队列的设计直接源自CLH锁，但做了适应性改造。\n2.2 AQS同步队列与CLH锁的核心差异AQS的同步队列虽然脱胎于CLH锁，但为了适应Java的线程模型（支持阻塞&#x2F;唤醒），做了以下关键改进：\n\n\n\n特性\nCLH锁\nAQS同步队列\n\n\n\n队列结构\n单向链表（隐式，通过前驱关联）\n双向链表（显式，prev+next指针）\n\n\n等待方式\n自旋（忙等）\n阻塞（LockSupport.park()）\n\n\n节点状态\n仅locked（是否持有锁）\n多状态（CANCELLED、SIGNAL等）\n\n\n锁释放通知方式\n修改前驱节点状态\n唤醒后继节点（unparkSuccessor）\n\n\n支持的操作类型\n仅独占锁\n独占锁+共享锁\n\n\n2.3 AQS的核心组件解析AQS的核心由三部分组成：状态变量（state）、同步队列（双向链表）、节点（Node）。\n2.3.1 状态变量（state）AQS通过volatile int state维护共享资源的状态，子类通过重写tryAcquire、tryRelease等方法操作state，实现不同的同步语义：\n\n对于ReentrantLock：state表示重入次数（0&#x3D;未锁定，&gt;0&#x3D;已锁定）；\n对于Semaphore：state表示剩余许可数；\n对于CountDownLatch：state表示倒计时次数。\n\nstate的修改必须通过原子操作（compareAndSetState）保证线程安全：\n// AQS中state的定义private volatile int state;// 原子更新state（CAS操作）protected final boolean compareAndSetState(int expect, int update) &#123;    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);&#125;\n\n\n2.3.2 节点（Node）结构AQS的Node是同步队列的基本单元，相比CLH的Node，它包含更丰富的状态和指针：\nstatic final class Node &#123;    // 共享模式标记    static final Node SHARED = new Node();    // 独占模式标记    static final Node EXCLUSIVE = null;    // 节点状态：取消（线程已中断或超时）    static final int CANCELLED =  1;    // 节点状态：后继节点需要被唤醒    static final int SIGNAL    = -1;    // 节点状态：线程在条件队列中等待    static final int CONDITION = -2;    // 节点状态：共享模式下，状态需要向后传播    static final int PROPAGATE = -3;    // 当前节点的状态（volatile保证可见性）    volatile int waitStatus;    // 前驱节点（双向链表）    volatile Node prev;    // 后继节点（双向链表）    volatile Node next;    // 当前节点关联的线程    volatile Thread thread;    // 条件队列中的后继节点（用于Condition）    Node nextWaiter;    // 判断是否为共享模式    final boolean isShared() &#123;        return nextWaiter == SHARED;    &#125;    // 获取前驱节点（为null则抛异常）    final Node predecessor() throws NullPointerException &#123;        Node p = prev;        if (p == null)            throw new NullPointerException();        else            return p;    &#125;    Node() &#123;&#125; // 用于创建初始头节点或SHARED标记    Node(Thread thread, Node mode) &#123; // 用于addWaiter        this.nextWaiter = mode;        this.thread = thread;    &#125;    Node(Thread thread, int waitStatus) &#123; // 用于Condition        this.waitStatus = waitStatus;        this.thread = thread;    &#125;&#125;\n\n核心要点：\n\nwaitStatus：节点的核心状态，用于控制线程的阻塞与唤醒（替代CLH的locked）；\n双向链表：prev+next指针，方便节点移除（如取消节点的清理）；\nthread：关联具体线程，便于唤醒时定位目标线程；\n支持两种模式：EXCLUSIVE（独占，如ReentrantLock）和SHARED（共享，如Semaphore）。\n\n2.3.3 同步队列（双向链表）AQS的同步队列是一个FIFO双向链表，由head（头节点）和tail（尾节点）维护：\n\nhead：表示当前持有锁的节点（哨兵节点，无实际线程）；\ntail：表示队列的最后一个节点；\n新线程竞争锁失败时，会被包装为Node加入队列尾部；\n锁释放时，head的后继节点会被唤醒并尝试获取锁。\n\n队列初始化时head和tail都为null，第一个线程竞争锁时会创建一个哨兵节点作为head。\n2.4 AQS的核心流程：独占锁的获取与释放以ReentrantLock的独占模式为例，解析AQS的核心流程（对应lock()和unlock()）。\n2.4.1 获取锁（acquire(int arg)）acquire是AQS获取独占锁的核心方法，流程为：“尝试获取锁→失败则入队→阻塞等待”。\npublic final void acquire(int arg) &#123;    // 1. 尝试获取锁（tryAcquire由子类实现，如ReentrantLock）    if (!tryAcquire(arg) &amp;&amp;        // 2. 尝试获取锁失败，将当前线程加入同步队列        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) &#123;        // 3. 如果需要，中断当前线程        selfInterrupt();    &#125;&#125;\n\n\n步骤1：tryAcquire（尝试获取锁）\ntryAcquire由子类实现，以ReentrantLock的非公平锁为例：\n// ReentrantLock.NonfairSync的tryAcquire实现protected final boolean tryAcquire(int acquires) &#123;    return nonfairTryAcquire(acquires);&#125;final boolean nonfairTryAcquire(int acquires) &#123;    final Thread current = Thread.currentThread();    int c = getState();    // 情况1：state=0（锁未被持有），直接CAS获取锁    if (c == 0) &#123;        if (compareAndSetState(0, acquires)) &#123;            setExclusiveOwnerThread(current); // 标记当前线程为持有者            return true;        &#125;    &#125;    // 情况2：当前线程已持有锁（重入），state+1    else if (current == getExclusiveOwnerThread()) &#123;        int nextc = c + acquires;        if (nextc &lt; 0) // 溢出检查            throw new Error(&quot;Maximum lock count exceeded&quot;);        setState(nextc);        return true;    &#125;    // 情况3：锁被其他线程持有，获取失败    return false;&#125;\n\n\n步骤2：addWaiter（入队）\n如果tryAcquire失败，addWaiter会将当前线程包装为Node，并加入同步队列尾部：\nprivate Node addWaiter(Node mode) &#123;    // 创建当前线程的节点（独占模式）    Node node = new Node(Thread.currentThread(), mode);    // 快速尝试：直接CAS将节点加入尾部（优化常见场景）    Node pred = tail;    if (pred != null) &#123;        node.prev = pred;        if (compareAndSetTail(pred, node)) &#123;            pred.next = node;            return node;        &#125;    &#125;    // 快速尝试失败，通过enq入队（处理队列初始化或并发竞争）    enq(node);    return node;&#125;// 循环CAS入队（保证节点一定能加入队列）private Node enq(final Node node) &#123;    for (;;) &#123;        Node t = tail;        // 队列未初始化（tail=null），创建哨兵节点作为head和tail        if (t == null) &#123;            if (compareAndSetHead(new Node()))                tail = head;        &#125; else &#123;            // 队列已初始化，CAS将节点加入尾部            node.prev = t;            if (compareAndSetTail(t, node)) &#123;                t.next = node;                return t;            &#125;        &#125;    &#125;&#125;\n\n\n步骤3：acquireQueued（阻塞等待）\n节点入队后，acquireQueued会让线程在队列中阻塞等待，直到获取锁或被中断：\nfinal boolean acquireQueued(final Node node, int arg) &#123;    boolean failed = true;    try &#123;        boolean interrupted = false;        // 自旋：不断检查是否能获取锁        for (;;) &#123;            final Node p = node.predecessor(); // 获取前驱节点            // 前驱是head（持有锁的节点），尝试获取锁            if (p == head &amp;&amp; tryAcquire(arg)) &#123;                setHead(node); // 成功获取锁，将当前节点设为新head（哨兵）                p.next = null; // 断开与旧head的联系，帮助GC                failed = false;                return interrupted; // 返回是否被中断过            &#125;            // 尝试获取锁失败，判断是否需要阻塞            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                parkAndCheckInterrupt()) &#123; // 阻塞当前线程                interrupted = true; // 记录中断状态            &#125;        &#125;    &#125; finally &#123;        if (failed)            cancelAcquire(node); // 失败则取消获取（标记节点为CANCELLED）    &#125;&#125;\n\n其中，shouldParkAfterFailedAcquire用于调整前驱节点状态，确保当前线程能被正确唤醒：\nprivate static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;    int ws = pred.waitStatus;    if (ws == Node.SIGNAL)        // 前驱状态为SIGNAL：当前线程可以安全阻塞（前驱释放锁时会唤醒它）        return true;    if (ws &gt; 0) &#123;        // 前驱状态为CANCELLED：跳过所有取消的节点，找到有效前驱        do &#123;            node.prev = pred = pred.prev;        &#125; while (pred.waitStatus &gt; 0);        pred.next = node;    &#125; else &#123;        // 前驱状态为0或PROPAGATE：将前驱状态设为SIGNAL（确保后续能唤醒当前节点）        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);    &#125;    return false;&#125;\n\nparkAndCheckInterrupt通过LockSupport.park阻塞线程，并返回中断状态：\nprivate final boolean parkAndCheckInterrupt() &#123;    LockSupport.park(this); // 阻塞当前线程    return Thread.interrupted(); // 清除中断状态并返回&#125;\n\n\n2.4.2 释放锁（release(int arg)）release是AQS释放独占锁的核心方法，流程为：“尝试释放锁→成功则唤醒后继节点”。\npublic final boolean release(int arg) &#123;    // 1. 尝试释放锁（tryRelease由子类实现）    if (tryRelease(arg)) &#123;        Node h = head;        // 2. 头节点存在且状态不为0，唤醒后继节点        if (h != null &amp;&amp; h.waitStatus != 0)            unparkSuccessor(h);        return true;    &#125;    return false;&#125;\n\n\n步骤1：tryRelease（尝试释放锁）\n以ReentrantLock为例，tryRelease的实现逻辑是减少state，当state减为0时表示完全释放锁：\n// ReentrantLock.Sync的tryRelease实现protected final boolean tryRelease(int releases) &#123;    int c = getState() - releases;    // 只有锁的持有者能释放锁    if (Thread.currentThread() != getExclusiveOwnerThread())        throw new IllegalMonitorStateException();    boolean free = false;    if (c == 0) &#123; // state=0表示完全释放        free = true;        setExclusiveOwnerThread(null); // 清除持有者    &#125;    setState(c);    return free;&#125;\n\n\n步骤2：unparkSuccessor（唤醒后继节点）\n锁释放后，unparkSuccessor会唤醒同步队列中等待的后继节点：\nprivate void unparkSuccessor(Node node) &#123;    int ws = node.waitStatus;    // 将当前节点状态重置为0    if (ws &lt; 0)        compareAndSetWaitStatus(node, ws, 0);    // 找到第一个有效后继节点（跳过CANCELLED节点）    Node s = node.next;    if (s == null || s.waitStatus &gt; 0) &#123;        s = null;        // 从尾部向前找（避免中间有取消的节点）        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)            if (t.waitStatus &lt;= 0)                s = t;    &#125;    // 唤醒后继节点的线程    if (s != null)        LockSupport.unpark(s.thread);&#125;\n\n\n2.5 AQS对CLH锁的优化总结AQS的同步队列在CLH锁的基础上，做了以下关键优化，使其更适合Java并发场景：\n\n从自旋到阻塞：CLH通过自旋等待锁，AQS通过LockSupport.park/unpark实现线程阻塞&#x2F;唤醒，大幅减少CPU消耗，适合长耗时锁场景。\n\n引入节点状态：CLH仅用locked表示状态，AQS的waitStatus支持CANCELLED、SIGNAL等多状态，解决了线程中断、超时等场景下的队列管理问题。\n\n双向链表：CLH是单向链表，AQS通过prev+next实现双向链表，便于移除取消节点（如shouldParkAfterFailedAcquire中跳过CANCELLED节点）。\n\n支持多模式：CLH仅支持独占锁，AQS通过SHARED&#x2F;EXCLUSIVE模式，同时支持独占（如ReentrantLock）和共享（如Semaphore）场景。\n\n条件队列：AQS在同步队列之外，通过ConditionObject实现条件队列（对应await/signal），解决了CLH无法支持“条件等待”的问题。\n\n\n三、AQS的扩展：共享模式与条件队列AQS的强大之处不仅在于独占锁的实现，还在于其对共享模式和条件队列的支持，这进一步扩展了其适用场景。\n3.1 共享模式（以Semaphore为例）共享模式下，多个线程可同时获取资源（如Semaphore的“许可”）。AQS通过acquireShared和releaseShared实现共享模式的获取与释放。\n获取共享资源（acquireShared）：\npublic final void acquireShared(int arg) &#123;    if (tryAcquireShared(arg) &lt; 0)        doAcquireShared(arg); // 失败则入队等待&#125;\n\ntryAcquireShared由子类实现（如Semaphore），返回值&lt;0表示获取失败，&#x3D;0表示获取成功但无剩余资源，&gt;0表示获取成功且有剩余资源。\n释放共享资源（releaseShared）：\npublic final boolean releaseShared(int arg) &#123;    if (tryReleaseShared(arg)) &#123;        doReleaseShared(); // 唤醒后继节点（可能多个）        return true;    &#125;    return false;&#125;\n\n共享模式的核心是“传播性”——一个线程释放资源后，可能唤醒多个等待线程（如Semaphore释放许可后，多个线程可同时获取）。\n3.2 条件队列（Condition）AQS通过ConditionObject实现条件队列，对应Object.wait()和Object.notify()的功能，但更灵活（一个锁可关联多个条件队列）。\n条件队列的核心操作是await()（进入等待）和signal()（唤醒）：\n\nawait()：将当前线程从同步队列移到条件队列，释放锁并阻塞；\nsignal()：将条件队列的线程移回同步队列，等待获取锁。\n\n// ConditionObject.await()的核心逻辑public final void await() throws InterruptedException &#123;    if (Thread.interrupted())        throw new InterruptedException();    // 1. 将当前线程加入条件队列    Node node = addConditionWaiter();    // 2. 释放当前持有的锁    int savedState = fullyRelease(node);    int interruptMode = 0;    // 3. 阻塞，直到被signal或中断    while (!isOnSyncQueue(node)) &#123;        LockSupport.park(this);        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)            break;    &#125;    // 4. 被唤醒后，尝试重新获取锁    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)        interruptMode = REINTERRUPT;    // 5. 清理条件队列中的取消节点    if (node.nextWaiter != null)        unlinkCancelledWaiters();    if (interruptMode != 0)        reportInterruptAfterWait(interruptMode);&#125;// ConditionObject.signal()的核心逻辑public final void signal() &#123;    if (!isHeldExclusively())        throw new IllegalMonitorStateException();    Node first = firstWaiter;    if (first != null)        doSignal(first); // 将条件队列的第一个节点移到同步队列&#125;\n\n\n四、总结：从CLH到AQS的设计哲学CLH锁作为自旋锁的经典实现，其“队列等待”和“公平性”思想为AQS奠定了基础。但AQS并非简单照搬，而是结合Java的线程模型（支持阻塞&#x2F;唤醒）和实际并发场景（长耗时操作、多模式同步），做了针对性优化：\n\n从“自旋”到“阻塞”：适应长耗时锁场景，减少CPU浪费；\n从“单状态”到“多状态”：通过waitStatus处理线程中断、超时等复杂场景；\n从“单向链表”到“双向链表”：提升队列管理效率，支持节点移除；\n从“单一模式”到“多模式”：同时支持独占和共享，覆盖更多同步需求。\n\nAQS的成功不仅在于其技术实现，更在于其“模板方法”设计模式——通过抽象方法（tryAcquire、tryRelease等）将同步逻辑的核心留给子类实现，自身仅负责队列管理和线程调度。这种设计使得AQS成为Java并发工具的“基础设施”，极大简化了同步工具的开发。\n理解从CLH到AQS的演进，不仅能帮助我们掌握Java并发的底层原理，更能体会到“借鉴-优化-适配”的技术创新思路——优秀的框架往往不是凭空创造，而是站在经典算法的肩膀上，结合实际场景不断演进的结果。\n","categories":["每日一论","锁"],"tags":["JUC"]}]