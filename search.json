[{"title":"悲观锁","url":"/everyone/2025/10/19/hello-world/","content":"一、悲观锁的由来：从 “超卖事故” 说起咱们先从两个场景切入，看懂为啥需要悲观锁：\n1. 生活场景：卫生间的 “并发冲突”你去公司卫生间，推门发现没人但没锁门 —— 这时候如果突然冲进来另一个人，就会发生 “资源冲突”。所以聪明的做法是 先反锁再使用：默认 “一定会有人抢”，提前锁死资源，自己用完再释放。\n2. 编程场景：不加锁的 “库存灾难”假设电商秒杀某商品，库存 100 件，1000 个用户同时下单。如果不加锁，代码可能写成这样：\n// 无锁的库存扣减（有严重问题！）class BadStock &#123;   private int stock = 100;   // 扣减库存：先判断再修改   public void deduct(int num) &#123;       if (stock &gt;= num) &#123; // 步骤1：判断库存           // 模拟网络延迟（比如查数据库、调用支付接口）           try &#123; Thread.sleep(10); &#125; catch (Exception e) &#123;&#125;           stock -= num; // 步骤2：扣减库存           System.out.println(&quot;扣减成功，剩余：&quot; + stock);       &#125;   &#125;&#125;\n\n运行结果灾难：1000 个线程同时执行时，会出现 “库存变成负数” 的超卖 —— 因为多个线程同时通过步骤 1 的判断，都认为库存充足，最后同时执行步骤 2 的扣减。\n这就是 并发冲突：多个线程同时操作共享资源（库存），导致数据混乱。悲观锁的诞生就是为了解决这个问题：操作前先上锁，同一时间只允许一个线程动手，像卫生间反锁一样阻断冲突。\n二、悲观锁的核心概念：3 个特点讲透\n悲观锁是一种 “先防御后操作” 的并发策略，它默认 “线程一定会抢资源”，所以在访问共享数据前主动获取锁，确保只有持锁线程能操作，其他线程必须排队等待。\n\n关键特点用 “卫生间模型” 类比：\n\n\n\n特点\n技术解释\n生活对应场景\n\n\n\n独占性\n锁被一个线程持有后，其他线程无权使用\n卫生间反锁后，只有里面的人能使用\n\n\n阻塞性\n没拿到锁的线程暂停执行，不会占用 CPU\n没抢到卫生间的人在门口排队等待\n\n\n强一致性\n能 100% 避免冲突，但会牺牲性能\n虽然排队费时间，但绝对不会撞车\n\n\n三、Java 中悲观锁的实现方式：2 种锁工具深度解析Java 里悲观锁分 “隐式锁”（synchronized）和 “显式锁”（ReentrantLock），两者原理和用法差异很大，重点用图示拆解难点。\n1. 隐式锁：synchronized（懒人专属，JVM 帮你管锁）synchronized 是 Java 自带的 “傻瓜式锁”，不用手动开关锁，JVM 自动处理一切。但底层的 Monitor（监视器锁）机制 是难点，必须看图理解。\n（1）Monitor 机制可视化解析（核心难点！）Monitor 本质是个 “管程模型”，像个带门卫的房间，共享资源（比如库存变量）放在房间里，只有拿到钥匙的线程能进。\n┌─────────────────────────────────┐│           Monitor（房间）        ││  ┌─────────┐                    ││  │  owner  │ → 线程A（持锁中）   │  线程C → 被阻塞，进入entrySet排队│  └─────────┘                    ││  ┌─────────┐                    │  线程D → 调用wait()，进入waitSet等待│  │ waitSet │ → 线程B（等待唤醒） ││  └─────────┘                    ││  ┌─────────┐                    ││  │ entrySet│ → 线程C（排队抢锁） ││  └─────────┘                    │└─────────────────────────────────┘\n\n关键逻辑（对应 synchronized 执行流程）：\n\n线程进入 synchronized 代码块时，会向 Monitor 申请 “钥匙”（加锁）；\n\n如果 Monitor 没人持有（owner 为空），线程直接成为 owner，独占资源；\n\n如果已有线程持有钥匙（比如线程 A），新线程（线程 C）会进入 entrySet 队列 阻塞等待；\n\n线程执行完代码块，或发生异常，JVM 会自动释放钥匙（owner 置空），并唤醒 entrySet 里的一个线程抢锁；\n\n如果线程在锁内调用 wait() 方法（比如等待其他线程通知），会暂时释放钥匙，进入 waitSet 队列，被 notify() 唤醒后再回 entrySet 排队。\n\n\n（2）synchronized 的 3 种用法（代码实战）class SyncDemo &#123;   // 1. 锁实例方法（锁对象是 this，即当前 SyncDemo 实例）   public synchronized void lockMethod() &#123;       // 业务逻辑   &#125;   // 2. 锁静态方法（锁对象是 SyncDemo.class，全类唯一）   public static synchronized void lockStaticMethod() &#123;       // 业务逻辑   &#125;   // 3. 锁代码块（锁对象可自定义，灵活控制粒度）   public void lockBlock() &#123;       Object lockObj = new Object();       synchronized (lockObj) &#123; // 只锁这部分代码           // 核心业务（比如库存扣减）       &#125;   &#125;&#125;\n\n2. 显式锁：ReentrantLock（灵活王者，手动控锁）Java 1.5 新增的 java.util.concurrent.locks.Lock 接口实现类，需要手动 lock() 加锁、unlock() 释放锁，功能比 synchronized 强 10 倍。核心难点是 AQS 框架原理。\n（1）AQS 框架可视化解析（必懂！）ReentrantLock 基于 AQS（AbstractQueuedSynchronizer） 实现，本质是个 “带优先级的排队系统”，用双向链表存储等待线程，通过 CAS 操作（Compare And Swap）控制锁的获取释放。\n┌─────────────────────────────────────────────┐│            ReentrantLock （锁对象）          ││  ┌─────────────┐  持有线程：线程A             ││  │   state=1   │  （state&gt;0表示锁被占用）     ││  └─────────────┘                             │└───────────────────────┬─────────────────────┘                       │                       ▼┌─────────────────────────────────────────────┐│          AQS 等待队列（双向链表）            ││  ┌───────────┐  ┌───────────┐  ┌───────────┐ ││  │  线程B    │→│  线程C    │→│  线程D    │ ││  │  等待中   │←│  等待中   │←│  等待中   │ ││  └───────────┘  └───────────┘  └───────────┘ │└─────────────────────────────────────────────┘\n\n关键逻辑：\n\n线程调用 lock() 时，AQS 先检查 state 变量（0 &#x3D; 无锁，&gt;0 &#x3D; 有锁）；\n\n如果 state=0，用 CAS 操作把 state 改成 1，线程成为持锁线程；\n\n如果 state≠0（锁被占用），线程封装成 Node 节点 加入等待队列，进入阻塞状态；\n\n持锁线程调用 unlock() 时，把 state 改回 0，唤醒队列头节点的线程重新抢锁。\n\n\n（2）ReentrantLock 的核心优势（代码实战）比 synchronized 多 3 个关键功能，全是解决实际问题的：\nimport java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;import java.util.concurrent.TimeUnit;class LockDemo &#123;   private final Lock lock = new ReentrantLock(true); // true=公平锁，默认非公平   // 优势1：支持超时加锁，避免死锁   public void tryLockWithTimeout() &#123;       try &#123;           // 尝试加锁，3秒没拿到就放弃           if (lock.tryLock(3, TimeUnit.SECONDS)) &#123;               try &#123;                   // 业务逻辑               &#125; finally &#123;                   lock.unlock(); // 必须在finally释放！               &#125;           &#125; else &#123;               System.out.println(&quot;抢锁超时，放弃操作&quot;);           &#125;       &#125; catch (InterruptedException e) &#123;           Thread.currentThread().interrupt();       &#125;   &#125;   // 优势2：支持中断等待   public void lockWithInterrupt() throws InterruptedException &#123;       lock.lockInterruptibly(); // 等待时可被中断       try &#123;           // 业务逻辑       &#125; finally &#123;           lock.unlock();       &#125;   &#125;   // 优势3：可重入性（同一线程多次加锁）   public void reentrantDemo() &#123;       lock.lock();       try &#123;           System.out.println(&quot;第一次加锁&quot;);           lock.lock(); // 同一线程再次加锁，不会死锁           try &#123;               System.out.println(&quot;第二次加锁&quot;);           &#125; finally &#123;               lock.unlock(); // 释放第二次锁           &#125;       &#125; finally &#123;           lock.unlock(); // 释放第一次锁（次数必须匹配！）       &#125;   &#125;&#125;\n\n（3）两种锁的核心区别（可视化对比表）\n\n\n维度\nsynchronized\nReentrantLock\n\n\n\n锁管理\n隐式（JVM 自动加解锁）\n显式（手动 lock&#x2F;unlock）\n\n\n功能\n仅基础同步\n支持超时、中断、公平锁\n\n\n可重入性\n支持（自动计数）\n支持（手动计数，需匹配释放次数）\n\n\n性能\nJDK1.6 后优化，与 Lock 接近\n高并发下略优，功能更灵活\n\n\n适用场景\n简单同步（单方法 &#x2F; 代码块）\n复杂场景（秒杀、分布式事务）\n\n\n// 图示：synchronized vs ReentrantLock 功能对比┌─────────────────────────────────────┐│            功能覆盖范围             ││  ┌─────────────┐  ┌─────────────┐   ││  │ ReentrantLock│  │ synchronized│   ││  │ （大圆圈）   │  │ （小圆圈）   │   ││  └─────────────┘  └─────────────┘   ││  超时锁  中断锁  公平锁  基础同步   │└─────────────────────────────────────┘\n\n四、悲观锁的应用场景：3 类场景必须用不是所有并发都需要悲观锁，这 3 种情况优先选：\n1. 高冲突场景：秒杀、抢购特点：1000 个线程抢 100 个资源，冲突概率极高。\n案例：电商秒杀库存扣减，用 ReentrantLock 加锁，配合超时机制避免线程拥堵。\n代码片段：\n2. 强一致性场景：金融交易特点：数据错 1 分钱都不行，必须 100% 准确。\n案例：银行转账（A 转 B 100 元），需保证 “A 扣钱” 和 “B 加钱” 原子执行，用 synchronized 或数据库悲观锁。\n数据库悲观锁示例（配合 Java 事务）：\n3. 长操作场景：批量数据处理特点：操作耗时久（比如批量导入 1000 条数据），期间容易被其他线程打断。\n案例：Excel 批量导入用户数据，需保证导入过程中数据不被篡改，用 ReentrantLock 加锁，避免中途冲突。\n五、使用悲观锁的注意事项：4 个坑别踩1. 坑 1：锁范围过大（“锁膨胀”）错误示范：把整个方法加锁，包括无关的查询操作：\n正确做法：只锁核心代码块（锁粒度最小化）：\n2. 坑 2：死锁（最致命！）死锁的 4 个必要条件（缺一不可，破坏任何一个即可避免）：\n死锁形成图示：\n线程A → 持有LOCK\\_A → 等待LOCK\\_B ▲                    │ │                    ▼线程B → 持有LOCK\\_B → 等待LOCK\\_A\n\n避免方法：\n\n统一锁顺序：所有线程都先拿 LOCK_A，再拿 LOCK_B（破坏 “循环等待”）；\n\n超时释放：用 ReentrantLock 的 tryLock(timeout)（破坏 “持有并等待”）；\n\n主动中断：用 lockInterruptibly() 响应中断（破坏 “不可剥夺”）。\n\n\n死锁检测工具：JDK 自带的 jconsole，步骤如下：\n\n启动程序，打开 JDK 的 bin 目录，双击 jconsole.exe；\n\n选择要监控的 Java 进程，点击 “连接”；\n\n切换到 “线程” 标签，点击 “检测死锁”，即可看到死锁线程信息。\n\n\n3. 坑 3：忽略可重入性的计数问题ReentrantLock 手动加锁 n 次，必须释放 n 次，否则锁不会释放：\n// 错误：加锁2次，释放1次，导致锁泄漏public void wrongReentrant() &#123;   lock.lock();   lock.lock(); // 第二次加锁   try &#123;       // 业务逻辑   &#125; finally &#123;       lock.unlock(); // 只释放1次，锁还被持有！   &#125;&#125;\n\n4. 坑 4：高并发下的性能瓶颈悲观锁会导致线程阻塞、上下文切换（线程从运行到阻塞再唤醒的开销）。如果并发量极高但冲突少（比如查询多、修改少的用户列表），用悲观锁会浪费 CPU，此时应换 乐观锁（用 version 字段判断数据是否被修改）。\n六、典型案例：从 “超卖” 到 “死锁修复” 全实战案例 1：synchronized 解决库存超卖（新手入门）需求：100 个线程同时扣减库存，避免超卖。\n完整代码 + 运行分析：\nclass SafeStockWithSync &#123;   private int stock = 100;   // 同步方法：锁对象是 this   public synchronized void deduct(int num) &#123;       if (stock &gt;= num) &#123;           System.out.println(Thread.currentThread().getName() +                              &quot;：当前库存&quot; + stock);           stock -= num;           System.out.println(Thread.currentThread().getName() +                              &quot;：扣减后&quot; + stock);       &#125; else &#123;           System.out.println(Thread.currentThread().getName() +                              &quot;：库存不足&quot;);       &#125;   &#125;&#125;public class SyncStockTest &#123;   public static void main(String\\[] args) &#123;       SafeStockWithSync stock = new SafeStockWithSync();       // 启动100个线程，每个扣1件       for (int i = 0; i &lt; 100; i++) &#123;           new Thread(() -&gt; stock.deduct(1), &quot;线程&quot; + i).start();       &#125;   &#125;&#125;\n\n运行结果：线程依次执行，库存从 100 减到 0，无超卖。因为 synchronized 保证了 deduct 方法同一时间只有一个线程能执行。\n案例 2：ReentrantLock 实现秒杀超时控制（进阶）需求：秒杀时，线程抢锁超过 2 秒就放弃，避免大量线程阻塞。\n核心代码：\n运行结果：部分线程抢锁成功，部分超时放弃，避免了所有线程阻塞等待。\n案例 3：死锁修复（反面→正面）反面案例：两个线程互相抢锁，导致死锁（原代码见前文）。\n修复方案：统一锁的获取顺序，都先拿 LOCK_A，再拿 LOCK_B。\n修复后代码：\n运行结果：线程 1 先拿到 A，执行完释放后，线程 2 拿到 A，不会死锁（破坏了 “循环等待” 条件）。\n七、总结：悲观锁的 “用武之地” 与 “避坑指南”1. 什么时候用？\n✅ 冲突多（秒杀、抢购）；\n\n✅ 一致性要求高（金融、支付）；\n\n✅ 操作时间长（批量处理、长事务）。\n\n\n2. 选 synchronized 还是 ReentrantLock？\n简单场景（单方法同步）→ 用 synchronized（省心，不易错）；\n\n复杂场景（超时、中断、公平锁）→ 用 ReentrantLock（灵活，功能强）。\n\n\n3. 核心避坑口诀：“锁粒度要小，顺序要统一，超时加中断，释放要牢记”。\n\n（注：文档部分内容可能由 AI 生成）\n\n","categories":["每日一论"],"tags":["悲观锁"]}]